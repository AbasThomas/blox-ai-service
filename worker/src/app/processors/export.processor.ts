import { Logger } from '@nestjs/common';
import { Processor, WorkerHost } from '@nestjs/bullmq';
import { Job } from 'bullmq';
import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';
import { PrismaService } from '../prisma/prisma.service';

@Processor('export')
export class ExportProcessor extends WorkerHost {
  private readonly logger = new Logger(ExportProcessor.name);

  constructor(private readonly prisma: PrismaService) {
    super();
  }

  async process(
    job: Job<{ assetId: string; userId: string; format: 'pdf' | 'json' | 'docx' }>,
  ) {
    const { assetId, userId, format } = job.data;
    this.logger.log(`[export] Job ${job.id} for asset ${assetId} as ${format}`);

    const asset = await this.prisma.asset.findFirst({ where: { id: assetId, userId } });
    if (!asset) throw new Error('Asset not found');

    const exportDir = join(process.cwd(), 'tmp', 'exports');
    await mkdir(exportDir, { recursive: true });

    const filename = `${assetId}-${Date.now()}.${format}`;
    const filepath = join(exportDir, filename);

    switch (format) {
      case 'json': {
        await writeFile(filepath, JSON.stringify({ asset, exportedAt: new Date().toISOString() }, null, 2));
        break;
      }
      case 'pdf': {
        // Generate a simple HTML-based PDF representation
        const html = this.renderToHtml(asset);
        // In production, use puppeteer or playwright here
        await writeFile(filepath.replace('.pdf', '.html'), html);
        this.logger.log(`[export] PDF export generated as HTML (puppeteer not available in dev)`);
        break;
      }
      case 'docx': {
        // Basic DOCX export - in production use docx npm package
        const text = JSON.stringify(asset.content, null, 2);
        await writeFile(filepath.replace('.docx', '.txt'), text);
        break;
      }
    }

    await this.prisma.notification.create({
      data: {
        userId,
        type: 'export_ready',
        title: `Your ${format.toUpperCase()} export is ready`,
        payload: { assetId, format, filename },
      },
    });

    return { assetId, format, filename, completedAt: new Date().toISOString() };
  }

  private renderToHtml(asset: { title: string; content: unknown }): string {
    const content = asset.content as Record<string, unknown>;
    const sections = (content.sections as Array<{ type: string; content: string }>) ?? [];

    return `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>${asset.title}</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 800px; margin: 40px auto; padding: 0 20px; line-height: 1.6; }
    h1 { color: #1a1a1a; border-bottom: 2px solid #6366f1; padding-bottom: 8px; }
    h2 { color: #4b5563; margin-top: 24px; }
    section { margin-bottom: 24px; }
  </style>
</head>
<body>
  <h1>${asset.title}</h1>
  ${sections.map((s) => `<section><h2>${s.type.charAt(0).toUpperCase() + s.type.slice(1)}</h2><p>${s.content}</p></section>`).join('\n')}
  <footer style="margin-top:40px;color:#999;font-size:12px;">Generated by Blox &mdash; ${new Date().toISOString()}</footer>
</body>
</html>`;
  }
}
